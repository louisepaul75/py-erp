Okay, here's a summary of our progress in centralizing the sync logic and the plan for the remaining workflows:

Progress Summary:

*   **Problem Identification:** Analyzed sync commands, finding duplicated arguments and inconsistent filter application.
*   **Centralized Solution:**
    *   Created `BaseSyncCommand` (`pyerp/sync/management/commands/base_sync_command.py`) defining common arguments (--full, --batch-size, --top, --days, --filters, etc.).
    *   Implemented `build_query_params` in the base command to standardize filter creation from arguments (using keys like `$top`, `modified_since`).
    *   Added `get_mapping` and `run_sync_via_command` helpers.
    *   Corrected filter generation logic in `run_sync_via_command` to properly handle `parent_record_ids`/`parent_field` and map specific keys like `legacy_id` to `__KEY` where necessary, preventing malformed filters.
*   **Refactored `sync_products.py`:**
    *   Inherits from `BaseSyncCommand`.
    *   Its `handle` method implements the multi-stage logic for targeted syncs (`--top`, `--sku`):
        1.  Fetches targeted parent data using the extractor via `build_query_params` and `fetch_data`.
        2.  Extracts `legacy_id` (from `__KEY`).
        3.  **Adaptation:** Directly processes the *fetched* parent record using its transformer and loader (bypassing `run_sync_via_command` for this step due to API limitations filtering `Artikel_Familie` by `__KEY`).
        4.  Constructs specific variant filters (`parent_record_ids`, `parent_field`).
        5.  Calls `run_sync_via_command` for variants, passing *only* the specific variant filters (using the corrected filter generation from the base command).
    *   Falls back to standard `run_sync_via_command` calls for non-targeted syncs.
*   **Debugging & Verification:**
    *   Successfully ran `sync_products --top=1 --clear-cache`, verifying the multi-stage logic:
        *   Parent record fetched and processed directly.
        *   Variant filter correctly generated (`'filters': '{"parent_record_ids": [...], "parent_field": "Familie_"}'`).
        *   Variant API call successful (`$filter='Familie_ = 7464...'`).
        *   Parent and its 2 variants were updated correctly.

Plan for Other Workflows:

The next step is to apply this pattern to the other sync commands:

1.  **Refactor `sync_sales_records.py`:**
    *   Inherit from `BaseSyncCommand`.
    *   Remove duplicated arguments.
    *   Adapt `handle` method:
        *   Call `self.build_query_params()` for initial filters.
        *   Use `PipelineFactory` and `fetch_data()` with initial filters to get parent `AbsNr` from `Belege`.
        *   Call `self.run_sync_via_command()` for `sales_records` using initial filters.
        *   Construct specific item filters: `{"parent_record_ids": [list_of_AbsNr_ids], "parent_field": "AbsNr"}` (or correct field name).
        *   Call `self.run_sync_via_command()` for `sales_record_items`, passing *only* item-specific filters (ensure `--top`, `--days` etc. from original command are not passed here).
2.  **Refactor Other Commands (`sync_customers`, `sync_inventory`, etc.):**
    *   Inherit from `BaseSyncCommand`.
    *   Remove duplicate arguments.
    *   Simplify `handle` for single-stage syncs:
        *   `get_mapping(...)`
        *   `build_query_params(...)`
        *   `run_sync_via_command(...)`
3.  **Verify/Update Extractors:**
    *   Confirm `LegacyAPIExtractor` handles `modified_since` (from `--days`) and `sku` filters correctly, translating them to the required OData `$filter` syntax. The handling of `$top` and `parent_record_ids`/`parent_field` seems correct based on `sync_products` test.

This systematic refactoring will significantly reduce code duplication and make filter handling consistent across all sync workflows. 