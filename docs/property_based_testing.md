# Property-Based Testing in pyERP

This document outlines how to use property-based testing in the pyERP project using Hypothesis for Python and jest-fuzz for JavaScript/TypeScript.

## What is Property-Based Testing?

Property-based testing is a testing technique where instead of writing individual test cases with specific input values and expected outputs, you define properties that should hold true for a range of inputs. The testing framework then generates random inputs and checks if these properties hold.

Benefits include:
- Identifying edge cases and unexpected behavior
- Testing functions with a broad range of inputs
- Finding bugs that traditional unit testing might miss

## Hypothesis for Python Testing

### Setup

Hypothesis is configured in the `pytest.ini` file with the following settings:

```ini
# Hypothesis settings
hypothesis-max-examples = 100
hypothesis-deadline = 1000
hypothesis-report-multiple-bugs = True
hypothesis-derandomize = False
hypothesis-verbosity = normal
```

These settings can be overridden in specific tests.

### Basic Usage

Here's a simple example:

```python
from hypothesis import given, strategies as st

@given(st.integers(), st.integers())
def test_addition_commutative(a, b):
    assert a + b == b + a
```

### Available Strategies

We've created many custom strategies in `pyerp/utils/testing/hypothesis_examples.py`:

- Basic data type strategies:
  - `text_strategy()` - Text strings
  - `email_strategy()` - Valid email addresses
  - `amount_strategy()` - Decimal amounts
  - `date_strategy()` - Date strings

- Business object strategies:
  - `product_strategy()` - Complete product data
  - `customer_strategy()` - Customer information
  - `order_strategy()` - Order data with optional line items

### Writing Property Tests

1. **Identify properties**: What invariants should always hold?
2. **Use appropriate strategies**: Choose or create strategies that generate relevant data
3. **Define property tests**: Use the `@given` decorator with your strategies
4. **Add examples if needed**: Use `@example` for specific test cases

Example:

```python
@given(product=product_strategy())
def test_product_validation(product):
    """Ensure that products generated by our strategies are valid."""
    # Call your validation function
    is_valid, errors = validate_product(product)
    
    # This should always be true for valid products
    assert is_valid
```

### Testing Django Models

Hypothesis provides special tools for Django:

```python
from hypothesis.extra.django import from_model

# Generate model instances directly
from myapp.models import Product
product_strategy = from_model(Product)

@given(product=product_strategy)
def test_product_model(product):
    # Test properties of the product model
    assert product.price >= 0
```

## Jest-Fuzz for JavaScript/TypeScript Testing

### Setup

Jest-Fuzz is configured to work with Jest and our existing test setup.

### Basic Usage

Here's a simple example:

```typescript
import { fuzz } from 'jest-fuzz';

fuzz.test('sum is commutative', [fuzz.number(), fuzz.number()], (a, b) => {
  expect(a + b).toEqual(b + a);
});
```

### Available Generators

We've created reusable generators in `frontend-react/src/__tests__/utils/fuzz-utils.ts`:

- Basic generators:
  - `stringGen()` - Text strings
  - `emailGen()` - Email addresses
  - `numberGen()` - Numeric values
  - `dateGen()` - Date objects

- Business object generators:
  - `productGen()` - Product data
  - `customerGen()` - Customer information
  - `orderGen()` - Order data with items

### Writing Fuzz Tests

1. Import the fuzz library and generators:
```typescript
import { fuzz } from 'jest-fuzz';
import { numberGen, stringGen } from './fuzz-utils';
```

2. Create a test with generators:
```typescript
fuzz.test(
  'truncateText respects max length',
  [stringGen(1, 100), numberGen(5, 50)],
  (text, maxLength) => {
    const truncated = truncateText(text, maxLength);
    
    // Property assertions
    expect(truncated.length).toBeLessThanOrEqual(maxLength + 3);
    
    if (text.length <= maxLength) {
      expect(truncated).toEqual(text);
    } else {
      expect(truncated.endsWith('...')).toBe(true);
    }
  }
);
```

3. Control the number of test iterations:
```typescript
fuzz.iterations(100).test(
  'test description',
  [generators...],
  (args...) => {
    // Test code
  }
);
```

## Best Practices

1. **Focus on properties not examples**: Define what must always be true, not specific examples
2. **Start with simple properties**: Begin with basic invariants and build up
3. **Use appropriate generators**: Create or combine generators that match your domain
4. **Combine with regular tests**: Property tests complement, not replace, traditional tests
5. **Use CI for seed reproduction**: Failed tests include a seed that can reproduce the issue

## Integration with CI/CD

Our CI pipeline runs both Hypothesis tests and jest-fuzz tests automatically. Failed property tests will include the seed that produced the failure, which you can use to reproduce and fix the issue.

## Resources

- [Hypothesis Documentation](https://hypothesis.readthedocs.io/)
- [Jest-Fuzz Documentation](https://github.com/MartinSandstrom/jest-fuzz)
- Example implementations:
  - Python: `pyerp/utils/testing/test_hypothesis_example.py`
  - JavaScript: `frontend-react/src/__tests__/utils/formatters.fuzz.test.ts` 