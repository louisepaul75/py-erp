# PyERP Co-located Tests

This document describes PyERP's approach to test organization, following Django best practices with co-located tests.

## Test Structure

Each Django app/module in the PyERP system has its own `tests` directory containing tests specific to that module:

```
pyerp/
├── core/
│   ├── models.py
│   ├── views.py
│   └── tests/                 # Core module tests
│       ├── __init__.py
│       ├── conftest.py        # Module-specific fixtures
│       ├── test_models.py
│       ├── test_views.py
│       └── api/               # Subdirectory for API tests
│           ├── __init__.py
│           └── test_api.py
└── utils/
    ├── helpers.py
    └── tests/                 # Utils module tests
        ├── __init__.py
        └── test_helpers.py
```

## Running Tests

### Running All Tests

```bash
# Run all tests in the project
python -m pytest
```

### Running Tests for a Specific Module

```bash
# Run all tests for a specific module
python -m pytest pyerp/core/tests/

# Run a specific test file
python -m pytest pyerp/core/tests/test_models.py

# Run a specific test function
python -m pytest pyerp/core/tests/test_models.py::test_my_function
```

### Running Tests by Category

Tests are organized by module but can be discovered by category using markers:

```bash
# Run all API tests across all modules
python -m pytest -m api

# Run all unit tests
python -m pytest -m unit
```

## Test Fixtures

### Global Fixtures

Global fixtures are defined in the root `conftest.py` file and are available to all tests.

### Module-Specific Fixtures

Each module's `tests/conftest.py` contains fixtures specific to that module. These fixtures are only available to tests within that module.

## Adding New Tests

1. Create test files in the appropriate module's `tests` directory
2. Use the naming convention `test_*.py` for test files
3. Use the naming convention `test_*` for test functions
4. Add appropriate pytest markers to categorize tests

Example:

```python
"""Tests for the core models."""

import pytest
from pyerp.core.models import MyModel

@pytest.mark.unit
def test_my_model_creation():
    """Test that the MyModel can be created correctly."""
    model = MyModel(name="Test")
    assert model.name == "Test"
```

## Test Categories

Tests are categorized using pytest markers:

- `unit`: Unit tests for individual components
- `api`: API tests
- `backend`: Backend service tests
- `core`: Core business logic tests
- `ui`: User interface tests
- `database`: Database-related tests

Add markers to your tests like this:

```python
@pytest.mark.unit
@pytest.mark.api
def test_my_function():
    """This test is both a unit test and an API test."""
    ...
```

## Benefits of Co-located Tests

1. **Django Best Practice:** Follows Django's recommended approach
2. **Better Discoverability:** Developers can find tests alongside the code they're working on
3. **Easier Maintenance:** When refactoring code, related tests are right there
4. **Modularity:** Each business module owns its tests
5. **Prevents Namespace Collisions:** Avoids import conflicts

## Migration from Legacy Structure

The test migration was completed using the `migrate_tests.py` script. If you find any issues with tests after migration, please report them.

## Coverage Reports

Coverage reports can be generated by running:

```bash
python -m pytest --cov=pyerp
```

For an HTML report:

```bash
python -m pytest --cov=pyerp --cov-report=html
``` 