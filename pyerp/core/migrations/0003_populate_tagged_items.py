# Generated by Django 5.0.6 on 2025-03-30 13:02

from django.db import migrations
from django.db.models.signals import post_save, m2m_changed # To temporarily disconnect signals


def populate_tagged_items(apps, schema_editor):
    """
    Migrates data from the old ManyToManyFields on ParentProduct and VariantProduct
    to the new generic TaggedItem model.
    """
    # Get models using apps.get_model to ensure we get the version from this migration's state
    Tag = apps.get_model('core', 'Tag')
    TaggedItem = apps.get_model('core', 'TaggedItem')
    ParentProduct = apps.get_model('products', 'ParentProduct')
    VariantProduct = apps.get_model('products', 'VariantProduct')
    ContentType = apps.get_model('contenttypes', 'ContentType')

    # Get content types for the product models
    parent_product_ct = ContentType.objects.get_for_model(ParentProduct)
    variant_product_ct = ContentType.objects.get_for_model(VariantProduct)

    # --- Data migration logic ---
    print("\nMigrating tags for ParentProduct...")
    tagged_item_buffer = []
    processed_parents = 0
    for product in ParentProduct.objects.all().iterator():
        # Access tags via the implicit through model name generated by Django
        # Assumes default naming: parentproduct_tags
        # Need to be careful here - this M2M field might not exist in this state
        # Let's access via the related name on the Tag model state instead.
        # This requires the related_name='parent_products' to be correct in the
        # temporary AlterField definition in the products 0004 migration.
        
        # Correction: The easiest way is to use the product instance itself, as the
        # M2M field still exists in the model state for this migration.
        for tag in product.tags.all():
            tagged_item_buffer.append(
                TaggedItem(
                    tag=tag,
                    content_type=parent_product_ct,
                    object_id=product.pk,
                )
            )
        processed_parents += 1
        if processed_parents % 500 == 0:
            print(f"  Processed {processed_parents} parent products...")
            TaggedItem.objects.bulk_create(tagged_item_buffer, ignore_conflicts=True)
            tagged_item_buffer = []

    # Create any remaining items for parents
    if tagged_item_buffer:
        TaggedItem.objects.bulk_create(tagged_item_buffer, ignore_conflicts=True)
        tagged_item_buffer = []
    print(f"Finished migrating tags for {processed_parents} ParentProducts.")

    print("Migrating tags for VariantProduct...")
    processed_variants = 0
    for product in VariantProduct.objects.all().iterator():
        for tag in product.tags.all():
            tagged_item_buffer.append(
                TaggedItem(
                    tag=tag,
                    content_type=variant_product_ct,
                    object_id=product.pk,
                )
            )
        processed_variants += 1
        if processed_variants % 500 == 0:
            print(f"  Processed {processed_variants} variant products...")
            TaggedItem.objects.bulk_create(tagged_item_buffer, ignore_conflicts=True)
            tagged_item_buffer = []
            
    # Create any remaining items for variants
    if tagged_item_buffer:
        TaggedItem.objects.bulk_create(tagged_item_buffer, ignore_conflicts=True)
    print(f"Finished migrating tags for {processed_variants} VariantProducts.")

def reverse_populate_tagged_items(apps, schema_editor):
    """
    Deletes the migrated TaggedItem data. Does not attempt to restore
    the old ManyToMany relationships.
    """
    TaggedItem = apps.get_model('core', 'TaggedItem')
    ParentProduct = apps.get_model('products', 'ParentProduct')
    VariantProduct = apps.get_model('products', 'VariantProduct')
    ContentType = apps.get_model('contenttypes', 'ContentType')

    parent_product_ct = ContentType.objects.get_for_model(ParentProduct)
    variant_product_ct = ContentType.objects.get_for_model(VariantProduct)

    print("\nDeleting TaggedItem entries for ParentProduct and VariantProduct...")
    TaggedItem.objects.filter(content_type__in=[parent_product_ct, variant_product_ct]).delete()
    print("Finished deleting relevant TaggedItem entries.")


class Migration(migrations.Migration):
    dependencies = [
        ('core', '0002_tag_taggeditem'),
        ('products', '0004_delete_tag_alter_parentproduct_tags_and_more'), # Depends on the products migration that alters M2M
        ('contenttypes', '0002_remove_content_type_name'), # Explicit dependency on contenttypes
    ]

    operations = [
        # Temporarily disconnect signals that might interfere during data migration
        # migrations.RunPython(migrations.RunPython.noop, reverse_code=migrations.RunPython.noop), # Placeholder if needed
        
        migrations.RunPython(populate_tagged_items, reverse_code=reverse_populate_tagged_items),
    ]
