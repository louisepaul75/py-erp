name: Deploy Application

on:
  push:
    branches:
      - prod
      - dev
      - 'release/**'
    tags:
      - 'v*'

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
    
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Check types with mypy
      run: |
        mypy .

  tests:
    needs: [lint]
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: pyerp_test
        ports:
          - 5432:5432
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
    
    - name: Test with pytest
      env:
        DJANGO_SETTINGS_MODULE: pyerp.settings.testing
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/pyerp_test
      run: |
        pytest --cov=. --cov-report=xml
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        token: d21bebd3-0087-4c7c-bb78-c9dcaa8e83b5
        file: ./coverage.xml
        fail_ci_if_error: false
        flags: unittests
        name: pyERP-coverage
        verbose: true
        
    - name: Check coverage thresholds
      run: |
        coverage report --fail-under=80 || echo "::warning::Coverage is below 80%"
        
    - name: Check branch-specific requirements
      run: |
        if [[ $GITHUB_REF == refs/heads/prod || $GITHUB_REF =~ refs/heads/release/.* ]]; then
          echo "Running additional checks for prod and release branches"
          # Add stricter checks for prod and release branches
          coverage report --fail-under=80 || exit 1
        fi

  determine_environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF == refs/heads/prod ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF == refs/heads/dev ]]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF =~ refs/heads/release/.* ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=unknown" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  build:
    runs-on: ubuntu-latest
    needs: [tests, determine_environment]
    if: needs.determine_environment.outputs.should_deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine_environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,format=short

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/production/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            ENVIRONMENT=${{ env.ENVIRONMENT }}

  deploy:
    runs-on: ubuntu-latest
    needs: [build, determine_environment]
    if: needs.determine_environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      ENVIRONMENT: ${{ needs.determine_environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up environment-specific deployment
        run: |
          echo "Deploying to $ENVIRONMENT environment"
          # Here you would typically:
          # 1. Connect to your servers (via SSH or deployment service)
          # 2. Pull the latest Docker image
          # 3. Update/restart containers
          # 4. Run necessary migrations
          # 5. Perform smoke tests
          
          # Example for development (placeholder):
          if [[ "$ENVIRONMENT" == "development" ]]; then
            echo "Running development deployment process"
            # Development-specific deployment steps
          
          # Example for staging (placeholder):
          elif [[ "$ENVIRONMENT" == "staging" ]]; then
            echo "Running staging deployment process"
            # Staging-specific deployment steps
          
          # Example for production (placeholder):
          elif [[ "$ENVIRONMENT" == "production" ]]; then
            echo "Running production deployment process"
            # Production-specific deployment steps
          fi

      - name: Run migrations
        if: env.ENVIRONMENT != 'production'
        run: |
          echo "Running database migrations for $ENVIRONMENT environment"
          # Automated migrations for non-production environments
          
      - name: Prepare migration script for production
        if: env.ENVIRONMENT == 'production'
        run: |
          echo "Preparing migration script for manual review"
          # For production, you might want to generate a migration script
          # but apply it manually after review

      - name: Post-deployment verification
        run: |
          echo "Verifying deployment in $ENVIRONMENT environment"
          # Add verification steps (health checks, smoke tests, etc.)

  notify:
    runs-on: ubuntu-latest
    needs: [deploy, determine_environment]
    if: always() && needs.determine_environment.outputs.should_deploy == 'true'
    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        run: |
          echo "Deployment to ${{ needs.determine_environment.outputs.environment }} succeeded"
          # Add notification mechanism (Slack, email, etc.)
      
      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "Deployment to ${{ needs.determine_environment.outputs.environment }} failed"
          # Add notification mechanism (Slack, email, etc.) 