name: Deploy Application

on:
  push:
    branches:
      - prod
      - dev
      - 'release/**'
    tags:
      - 'v*'
  pull_request:
    types: [closed]
    branches:
      - prod

jobs:
  check_pr_merge:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'prod' && github.event.pull_request.head.ref == 'dev'
    steps:
      - name: Set deployment flag
        run: echo "DEPLOY_PROD=true" >> $GITHUB_ENV

  lint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
    
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Check types with mypy
      run: |
        mypy .

  tests:
    needs: [lint]
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: pyerp_test
        ports:
          - 5432:5432
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
    
    - name: Test with pytest
      env:
        DJANGO_SETTINGS_MODULE: pyerp.settings.testing
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/pyerp_test
      run: |
        pytest --cov=. --cov-report=xml
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        token: d21bebd3-0087-4c7c-bb78-c9dcaa8e83b5
        file: ./coverage.xml
        fail_ci_if_error: false
        flags: unittests
        name: pyERP-coverage
        verbose: true
        
    - name: Check coverage thresholds
      run: |
        coverage report --fail-under=80 || echo "::warning::Coverage is below 80%"
        
    - name: Check branch-specific requirements
      run: |
        if [[ $GITHUB_REF == refs/heads/prod || $GITHUB_REF =~ refs/heads/release/.* ]]; then
          echo "Running additional checks for prod and release branches"
          # Add stricter checks for prod and release branches
          coverage report --fail-under=80 || exit 1
        fi

  determine_environment:
    runs-on: ubuntu-latest
    needs: [tests]
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF == refs/heads/prod ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF == refs/heads/dev ]]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF =~ refs/heads/release/.* ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" && "${{ github.event.pull_request.base.ref }}" == "prod" && "${{ github.event.pull_request.head.ref }}" == "dev" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=unknown" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  build:
    runs-on: ubuntu-latest
    needs: [determine_environment]
    if: needs.determine_environment.outputs.should_deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine_environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,format=short

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/Dockerfile.prod
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            ENVIRONMENT=${{ env.ENVIRONMENT }}

  deploy:
    runs-on: ubuntu-latest
    needs: [build, determine_environment]
    if: needs.determine_environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      ENVIRONMENT: ${{ needs.determine_environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH
        if: env.ENVIRONMENT == 'production'
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}

      - name: Deploy to Production Server
        if: env.ENVIRONMENT == 'production'
        env:
          DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
        run: |
          # Ensure SSH connection works and host key is verified
          mkdir -p ~/.ssh
          ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts
          
          # Copy necessary files to the server
          scp -r docker/ $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/
          scp -r config/ $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/
          
          # Connect to server and deploy
          ssh $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
            cd $DEPLOY_PATH
            
            # Pull the latest image
            docker pull ghcr.io/${{ github.repository }}:$(echo ${{ github.ref }} | sed -e "s/refs\/heads\///g" | sed -e "s/\//-/g")
            
            # Stop and remove existing containers
            docker-compose -f docker/docker-compose.prod.yml down || true
            
            # Start the new containers
            docker-compose -f docker/docker-compose.prod.yml up -d
            
            # Run migrations
            docker-compose -f docker/docker-compose.prod.yml exec -T pyerp python manage.py migrate --noinput
            
            # Collect static files
            docker-compose -f docker/docker-compose.prod.yml exec -T pyerp python manage.py collectstatic --noinput
            
            # Check if deployment was successful
            docker-compose -f docker/docker-compose.prod.yml ps
          EOF

      - name: Deploy to Development/Staging Server
        if: env.ENVIRONMENT == 'development' || env.ENVIRONMENT == 'staging'
        env:
          DEPLOY_HOST: ${{ secrets.DEV_DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEV_DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEV_DEPLOY_PATH }}
        run: |
          # Set up SSH for dev/staging
          mkdir -p ~/.ssh
          echo "${{ secrets.DEV_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts
          
          # Copy necessary files to the server
          scp -r docker/ $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/
          scp -r config/ $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/
          
          # Connect to server and deploy
          ssh $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
            cd $DEPLOY_PATH
            
            # Pull the latest image
            docker pull ghcr.io/${{ github.repository }}:$(echo ${{ github.ref }} | sed -e "s/refs\/heads\///g" | sed -e "s/\//-/g")
            
            # Stop and remove existing containers
            docker-compose -f docker/docker-compose.yml down || true
            
            # Start the new containers
            docker-compose -f docker/docker-compose.yml up -d
            
            # Run migrations
            docker-compose -f docker/docker-compose.yml exec -T pyerp python manage.py migrate --noinput
            
            # Collect static files
            docker-compose -f docker/docker-compose.yml exec -T pyerp python manage.py collectstatic --noinput
            
            # Check if deployment was successful
            docker-compose -f docker/docker-compose.yml ps
          EOF

  notify:
    runs-on: ubuntu-latest
    needs: [deploy, determine_environment]
    if: always() && needs.determine_environment.outputs.should_deploy == 'true'
    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        run: |
          echo "Deployment to ${{ needs.determine_environment.outputs.environment }} succeeded"
          # Add notification mechanism (Slack, email, etc.)
          # Example for Slack:
          # curl -X POST -H 'Content-type: application/json' --data '{"text":"✅ Deployment to ${{ needs.determine_environment.outputs.environment }} succeeded"}' ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "Deployment to ${{ needs.determine_environment.outputs.environment }} failed"
          # Add notification mechanism (Slack, email, etc.)
          # Example for Slack:
          # curl -X POST -H 'Content-type: application/json' --data '{"text":"❌ Deployment to ${{ needs.determine_environment.outputs.environment }} failed"}' ${{ secrets.SLACK_WEBHOOK_URL }} 