---
description: This document outlines comprehensive testing standards and practices for the pyERP system. It provides guidelines for writing effective tests that ensure code quality, catch bugs early, and maintain system reliability across all components.
globs: **/tests/*.py, **/test_*.py
---
# Unit Testing Standards for pyERP

## Overview
This document outlines testing standards and practices for the pyERP system. It provides guidelines for writing effective tests that ensure code quality and maintain system reliability.

## Test Structure

### 1. Test File Organization
```python
# test_legacy_api_client.py

import pytest
from unittest.mock import patch, MagicMock
from django.test import TestCase

from pyerp.legacy_api.client import LegacyAPIClient
from pyerp.legacy_api.exceptions import AuthenticationError, ConnectionError

@pytest.fixture
def mock_api_response():
    return {
        'status': 'success',
        'data': [
            {'id': 1, 'name': 'Product 1'},
            {'id': 2, 'name': 'Product 2'}
        ]
    }

class TestLegacyAPIClient(TestCase):
    def setUp(self):
        self.client = LegacyAPIClient(environment='test')
        
    @patch('pyerp.legacy_api.client.requests.post')
    def test_authentication_success(self, mock_post):
        # Setup mock response
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'status': 'success', 'session': 'test_session_id'}
        mock_post.return_value = mock_response
        
        # Perform authentication
        self.client.authenticate()
        
        # Assert authentication was successful
        self.assertTrue(self.client.is_authenticated)
        self.assertEqual(self.client.session_id, 'test_session_id')
        
    @patch('pyerp.legacy_api.client.requests.post')
    def test_authentication_failure(self, mock_post):
        # Setup mock response for failure
        mock_response = MagicMock()
        mock_response.status_code = 401
        mock_response.json.return_value = {'status': 'error', 'message': 'Invalid credentials'}
        mock_post.return_value = mock_response
        
        # Assert authentication fails with appropriate exception
        with self.assertRaises(AuthenticationError):
            self.client.authenticate()
```

## Testing Categories

### 1. Unit Tests
Tests for individual functions, methods, and classes in isolation.

```python
# test_stock_calculation.py

import pytest
from decimal import Decimal
from django.test import TestCase

from pyerp.inventory.utils import calculate_stock_value
from pyerp.products.models import Product
from pyerp.inventory.models import StockItem

class TestStockCalculation(TestCase):
    def setUp(self):
        # Create test products
        self.product = Product.objects.create(
            sku='TEST001',
            name='Test Product',
            cost=Decimal('10.00')
        )
        
        # Create stock items
        self.stock_item1 = StockItem.objects.create(
            product=self.product,
            warehouse_id=1,
            quantity=5
        )
        self.stock_item2 = StockItem.objects.create(
            product=self.product,
            warehouse_id=2,
            quantity=10
        )
    
    def test_calculate_stock_value_single_warehouse(self):
        # Test for a single warehouse
        value = calculate_stock_value(self.product.id, warehouse_id=1)
        self.assertEqual(value, Decimal('50.00'))  # 5 * 10.00
        
    def test_calculate_stock_value_all_warehouses(self):
        # Test for all warehouses
        value = calculate_stock_value(self.product.id)
        self.assertEqual(value, Decimal('150.00'))  # (5 + 10) * 10.00
```

### 2. Integration Tests
Tests that verify the interaction between components.

```python
# test_product_api.py

from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase
from django.contrib.auth.models import User, Permission

from pyerp.products.models import Product, Category

class TestProductAPI(APITestCase):
    def setUp(self):
        # Create user with permissions
        self.user = User.objects.create_user(
            username='testuser', 
            password='password123'
        )
        self.user.user_permissions.add(
            Permission.objects.get(codename='view_product')
        )
        self.client.force_authenticate(user=self.user)
        
        # Create test data
        self.category = Category.objects.create(name='Test Category')
        self.product = Product.objects.create(
            sku='TEST001',
            name='Test Product',
            category=self.category,
            price=Decimal('99.99')
        )
        
    def test_get_product_list(self):
        url = reverse('api:product-list')
        response = self.client.get(url)
        
        # Check response status and content
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['sku'], 'TEST001')
```

### 3. Model Tests
Tests specific to Django models.

```python
# test_product_model.py

from django.test import TestCase
from django.core.exceptions import ValidationError
from decimal import Decimal

from pyerp.products.models import Product, BOMItem

class TestProductModel(TestCase):
    def setUp(self):
        self.product = Product.objects.create(
            sku='PARENT001',
            name='Parent Product',
            is_manufactured=True,
            cost=Decimal('0')  # Cost will be calculated from BOM
        )
        
        self.component1 = Product.objects.create(
            sku='COMP001',
            name='Component 1',
            cost=Decimal('10.00')
        )
        
        self.component2 = Product.objects.create(
            sku='COMP002',
            name='Component 2',
            cost=Decimal('5.00')
        )
        
        # Create BOM items
        BOMItem.objects.create(
            parent=self.product,
            component=self.component1,
            quantity=2
        )
        
        BOMItem.objects.create(
            parent=self.product,
            component=self.component2,
            quantity=3
        )
    
    def test_bom_cost_calculation(self):
        # Test that product cost is calculated correctly from BOM
        expected_cost = (2 * Decimal('10.00')) + (3 * Decimal('5.00'))  # 2*10 + 3*5 = 35
        self.product.update_cost_from_bom()
        self.assertEqual(self.product.cost, expected_cost)
```

### 4. View Tests
Tests for Django views.

```python
# test_product_views.py

from django.test import TestCase
from django.urls import reverse
from django.contrib.auth.models import User

from pyerp.products.models import Product

class TestProductViews(TestCase):
    def setUp(self):
        # Create test user and login
        self.user = User.objects.create_user(
            username='testuser', 
            password='password123'
        )
        self.client.login(username='testuser', password='password123')
        
        # Create test product
        self.product = Product.objects.create(
            sku='TEST001',
            name='Test Product',
            price=Decimal('99.99')
        )
    
    def test_product_detail_view(self):
        url = reverse('products:detail', args=[self.product.id])
        response = self.client.get(url)
        
        # Test response status
        self.assertEqual(response.status_code, 200)
        
        # Test context data
        self.assertEqual(response.context['product'].sku, 'TEST001')
        
        # Test template used
        self.assertTemplateUsed(response, 'products/detail.html')
```

### 5. Legacy API Tests
Specialized tests for the legacy 4D API integration.

```python
# test_legacy_api_integration.py

import pytest
from unittest.mock import patch, MagicMock
from django.test import TestCase

from pyerp.legacy_api import get_table_data, push_field_update
from pyerp.legacy_api.exceptions import LegacyAPIError

class TestLegacyAPIIntegration(TestCase):
    @patch('pyerp.legacy_api.client.LegacyAPIClient')
    def test_get_table_data(self, mock_client_class):
        # Setup mock client
        mock_client = MagicMock()
        mock_client.get_table_data.return_value = [
            {'id': 1, 'name': 'Product 1'},
            {'id': 2, 'name': 'Product 2'}
        ]
        mock_client_class.return_value = mock_client
        
        # Call function under test
        result = get_table_data('products', limit=10)
        
        # Assert expected results
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['name'], 'Product 1')
        
        # Verify correct parameters were used
        mock_client.get_table_data.assert_called_once_with('products', limit=10)
```

## Testing Best Practices

### 1. Test Independence
- Each test should be independent of others
- Use setUp and tearDown to create and clean up test data
- Avoid dependencies between tests

### 2. Test Coverage
- Aim for at least 80% code coverage
- Cover all major functionality
- Include edge cases and error conditions
- Test both positive and negative scenarios

### 3. Mock External Dependencies
- Use unittest.mock for external services
- Mock database calls when appropriate
- Simulate API responses

### 4. Testing Asynchronous Code
- Use async test methods for async code
- Consider using pytest-asyncio
- Test timeouts and cancellations

### 5. Database Testing
- Use Django's TestCase for database tests
- Consider using TransactionTestCase for transaction tests
- Use setUp to create test data
- Clean up after tests

## Testing Legacy API Integration

### 1. Mock HTTP Requests
```python
@patch('pyerp.legacy_api.client.requests.get')
def test_api_request(self, mock_get):
    # Setup mock response
    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {'status': 'success', 'data': [...]}
    mock_get.return_value = mock_response
    
    # Test API function
    result = legacy_api_function()
    
    # Assertions
    self.assertEqual(result, expected_result)
```

### 2. Testing Error Handling
```python
@patch('pyerp.legacy_api.client.requests.get')
def test_api_error_handling(self, mock_get):
    # Setup mock error response
    mock_response = MagicMock()
    mock_response.status_code = 500
    mock_response.json.return_value = {'status': 'error', 'message': 'Server error'}
    mock_get.return_value = mock_response
    
    # Test error handling
    with self.assertRaises(LegacyAPIError):
        legacy_api_function()
```

### 3. Testing Session Management
```python
def test_session_expiration(self):
    # Setup expired session
    client = LegacyAPIClient()
    client.session_id = 'expired_session'
    client.session_expiry = datetime.now() - timedelta(hours=2)
    
    # Test that client refreshes session
    with patch.object(client, '_refresh_session') as mock_refresh:
        client.get_table_data('products')
        mock_refresh.assert_called_once()
```

## Running Tests

### 1. Running All Tests
```bash
# Activate the virtual environment
.\venv\Scripts\activate

# Run all tests
python manage.py test
```

### 2. Running Specific Tests
```bash
# Run tests in a specific app
python manage.py test pyerp.products

# Run a specific test class
python manage.py test pyerp.products.tests.test_models.TestProductModel

# Run a specific test method
python manage.py test pyerp.products.tests.test_models.TestProductModel.test_bom_cost_calculation
```

### 3. Using pytest
```bash
# Install pytest
pip install pytest pytest-django

# Run tests with pytest
pytest

# Run with coverage
pytest --cov=pyerp
```

## Test Environment Considerations

### 1. Test Database
- Tests use a separate test database
- Database is created and destroyed for each test run
- Use migrations to ensure schema matches production

### 2. Environment Variables
- Set appropriate test environment variables
- Use test-specific settings
- Consider using django-environ for environment management

### 3. CI/CD Integration
- Configure tests to run in CI/CD pipeline
- Fail pipeline on test failures
- Generate and track coverage reports

## Test Documentation

### 1. Test Docstrings
```python
def test_calculate_reorder_point(self):
    """
    Test that reorder point calculation:
    1. Correctly calculates based on lead time and usage
    2. Handles edge cases (zero usage, long lead time)
    3. Raises appropriate exceptions for invalid inputs
    """
```

### 2. Test Naming
- Use descriptive test method names
- Follow pattern: test_[function]_[scenario]_[expected]
- Examples:
  - test_calculate_stock_value_empty_warehouse
  - test_authentication_with_invalid_credentials_raises_error 